package bookops

import (
	"context"
	"testing"

	"github.com/stretchr/testify/mock"

	"library-service/internal/adapters/repository/mocks"
	"library-service/internal/domain/author"
	"library-service/internal/domain/book"
	"library-service/internal/infrastructure/store"
	"library-service/pkg/errors"
	"library-service/test/testutil"
)

// mockAuthorRepository is a mock implementation of author.Repository for testing
type mockAuthorRepository struct {
	mock.Mock
}

func (m *mockAuthorRepository) Add(ctx context.Context, data author.Author) (string, error) {
	args := m.Called(ctx, data)
	return args.String(0), args.Error(1)
}

func (m *mockAuthorRepository) Get(ctx context.Context, id string) (author.Author, error) {
	args := m.Called(ctx, id)
	return args.Get(0).(author.Author), args.Error(1)
}

func (m *mockAuthorRepository) Update(ctx context.Context, id string, data author.Author) error {
	args := m.Called(ctx, id, data)
	return args.Error(0)
}

func (m *mockAuthorRepository) Delete(ctx context.Context, id string) error {
	args := m.Called(ctx, id)
	return args.Error(0)
}

func (m *mockAuthorRepository) List(ctx context.Context) ([]author.Author, error) {
	args := m.Called(ctx)
	return args.Get(0).([]author.Author), args.Error(1)
}

// mockAuthorCache is a mock implementation of author.Cache for testing
type mockAuthorCache struct {
	mock.Mock
}

func (m *mockAuthorCache) Get(ctx context.Context, id string) (author.Author, error) {
	args := m.Called(ctx, id)
	return args.Get(0).(author.Author), args.Error(1)
}

func (m *mockAuthorCache) Set(ctx context.Context, id string, data author.Author) error {
	args := m.Called(ctx, id, data)
	return args.Error(0)
}

// Helper to create a valid author
func validAuthor() author.Author {
	return author.Author{
		FullName:  strPtr("Robert C. Martin"),
		Pseudonym: strPtr("Uncle Bob"),
		Specialty: strPtr("Software Engineering"),
	}
}

func TestListBookAuthorsUseCase_Execute(t *testing.T) {
	tests := []struct {
		name         string
		request      ListBookAuthorsRequest
		setupMocks   func(*mocks.MockRepository, *mockAuthorRepository, *mockAuthorCache)
		expectError  bool
		errorCheck   func(*testing.T, error)
		validateFunc func(*testing.T, ListBookAuthorsResponse)
	}{
		{
			name: "successful retrieval with multiple authors from cache",
			request: ListBookAuthorsRequest{
				BookID: "book-123",
			},
			setupMocks: func(bookRepo *mocks.MockRepository, authorRepo *mockAuthorRepository, authorCache *mockAuthorCache) {
				// Book exists with 2 authors
				bookEntity := validBook()
				bookEntity.ID = "book-123"
				bookEntity.Authors = []string{"author-1", "author-2"}

				bookRepo.EXPECT().
					Get(mock.Anything, "book-123").
					Return(bookEntity, nil).
					Once()

				// Both authors found in cache
				author1 := validAuthor()
				author1.ID = "author-1"
				author1.FullName = strPtr("Robert C. Martin")

				author2 := validAuthor()
				author2.ID = "author-2"
				author2.FullName = strPtr("Martin Fowler")

				// Cache calls will happen concurrently, so use Maybe()
				authorCache.On("Get", mock.Anything, "author-1").
					Return(author1, nil).
					Maybe()
				authorCache.On("Get", mock.Anything, "author-2").
					Return(author2, nil).
					Maybe()
			},
			expectError: false,
			validateFunc: func(t *testing.T, resp ListBookAuthorsResponse) {
				testutil.AssertEqual(t, "book-123", resp.BookID)
				testutil.AssertEqual(t, 2, len(resp.Authors))
				// Note: Order may vary due to concurrent fetching
			},
		},
		{
			name: "successful retrieval with authors from repository (cache miss)",
			request: ListBookAuthorsRequest{
				BookID: "book-456",
			},
			setupMocks: func(bookRepo *mocks.MockRepository, authorRepo *mockAuthorRepository, authorCache *mockAuthorCache) {
				// Book exists with 1 author
				bookEntity := validBook()
				bookEntity.ID = "book-456"
				bookEntity.Authors = []string{"author-3"}

				bookRepo.EXPECT().
					Get(mock.Anything, "book-456").
					Return(bookEntity, nil).
					Once()

				// Cache miss
				authorCache.On("Get", mock.Anything, "author-3").
					Return(author.Author{}, errors.ErrNotFound).
					Maybe()

				// Repository retrieval
				author3 := validAuthor()
				author3.ID = "author-3"

				authorRepo.On("Get", mock.Anything, "author-3").
					Return(author3, nil).
					Maybe()

				// Cache update
				authorCache.On("Set", mock.Anything, "author-3", mock.Anything).
					Return(nil).
					Maybe()
			},
			expectError: false,
			validateFunc: func(t *testing.T, resp ListBookAuthorsResponse) {
				testutil.AssertEqual(t, "book-456", resp.BookID)
				testutil.AssertEqual(t, 1, len(resp.Authors))
			},
		},
		{
			name: "empty BookID validation error",
			request: ListBookAuthorsRequest{
				BookID: "",
			},
			setupMocks: func(bookRepo *mocks.MockRepository, authorRepo *mockAuthorRepository, authorCache *mockAuthorCache) {
				// No mocks should be called
			},
			expectError: true,
			errorCheck: func(t *testing.T, err error) {
				testutil.AssertError(t, err)
				testutil.AssertStringContains(t, err.Error(), "Invalid input")
			},
		},
		{
			name: "book not found error",
			request: ListBookAuthorsRequest{
				BookID: "non-existent-book",
			},
			setupMocks: func(bookRepo *mocks.MockRepository, authorRepo *mockAuthorRepository, authorCache *mockAuthorCache) {
				bookRepo.EXPECT().
					Get(mock.Anything, "non-existent-book").
					Return(book.Book{}, store.ErrorNotFound).
					Once()
			},
			expectError: true,
			errorCheck: func(t *testing.T, err error) {
				testutil.AssertError(t, err)
				testutil.AssertStringContains(t, err.Error(), "not found")
			},
		},
		{
			name: "book has no authors (empty list)",
			request: ListBookAuthorsRequest{
				BookID: "book-no-authors",
			},
			setupMocks: func(bookRepo *mocks.MockRepository, authorRepo *mockAuthorRepository, authorCache *mockAuthorCache) {
				// Book exists but has no authors
				bookEntity := validBook()
				bookEntity.ID = "book-no-authors"
				bookEntity.Authors = []string{}

				bookRepo.EXPECT().
					Get(mock.Anything, "book-no-authors").
					Return(bookEntity, nil).
					Once()
			},
			expectError: false,
			validateFunc: func(t *testing.T, resp ListBookAuthorsResponse) {
				testutil.AssertEqual(t, "book-no-authors", resp.BookID)
				testutil.AssertEqual(t, 0, len(resp.Authors))
			},
		},
		{
			name: "repository error when fetching book",
			request: ListBookAuthorsRequest{
				BookID: "book-error",
			},
			setupMocks: func(bookRepo *mocks.MockRepository, authorRepo *mockAuthorRepository, authorCache *mockAuthorCache) {
				bookRepo.EXPECT().
					Get(mock.Anything, "book-error").
					Return(book.Book{}, errors.ErrDatabase).
					Once()
			},
			expectError: true,
			errorCheck: func(t *testing.T, err error) {
				testutil.AssertError(t, err)
			},
		},
		{
			name: "some authors not found (should skip them)",
			request: ListBookAuthorsRequest{
				BookID: "book-missing-authors",
			},
			setupMocks: func(bookRepo *mocks.MockRepository, authorRepo *mockAuthorRepository, authorCache *mockAuthorCache) {
				// Book exists with 2 authors, but one doesn't exist
				bookEntity := validBook()
				bookEntity.ID = "book-missing-authors"
				bookEntity.Authors = []string{"author-exists", "author-missing"}

				bookRepo.EXPECT().
					Get(mock.Anything, "book-missing-authors").
					Return(bookEntity, nil).
					Once()

				// First author found in cache
				authorExists := validAuthor()
				authorExists.ID = "author-exists"

				authorCache.On("Get", mock.Anything, "author-exists").
					Return(authorExists, nil).
					Maybe()

				// Second author not found (cache miss, then repo miss)
				authorCache.On("Get", mock.Anything, "author-missing").
					Return(author.Author{}, errors.ErrNotFound).
					Maybe()
				authorRepo.On("Get", mock.Anything, "author-missing").
					Return(author.Author{}, store.ErrorNotFound).
					Maybe()
			},
			expectError: false,
			validateFunc: func(t *testing.T, resp ListBookAuthorsResponse) {
				testutil.AssertEqual(t, "book-missing-authors", resp.BookID)
				// Should only return the author that was found
				testutil.AssertEqual(t, 1, len(resp.Authors))
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Setup mocks
			mockBookRepo := mocks.NewMockRepository(t)
			mockAuthorRepo := new(mockAuthorRepository)
			mockAuthorCache := new(mockAuthorCache)
			tt.setupMocks(mockBookRepo, mockAuthorRepo, mockAuthorCache)

			// Create use case
			uc := NewListBookAuthorsUseCase(mockBookRepo, mockAuthorRepo, mockAuthorCache)

			// Execute
			ctx := context.Background()
			result, err := uc.Execute(ctx, tt.request)

			// Assert
			if tt.expectError {
				testutil.AssertError(t, err)
				if tt.errorCheck != nil {
					tt.errorCheck(t, err)
				}
			} else {
				testutil.AssertNoError(t, err)
				if tt.validateFunc != nil {
					tt.validateFunc(t, result)
				}
			}

			// Verify book repo expectations
			// Author repo expectations checked via testify's automatic verification
		})
	}
}
