package bookops

import (
	"context"
	"testing"

	"github.com/stretchr/testify/mock"

	"library-service/internal/adapters/repository/mocks"
	"library-service/internal/infrastructure/store"
	"library-service/pkg/errors"
	"library-service/test/testutil"
)

func TestUpdateBookUseCase_Execute(t *testing.T) {
	tests := []struct {
		name        string
		request     UpdateBookRequest
		setupMocks  func(*mocks.MockRepository, *mocks.MockCache)
		expectError bool
		errorCheck  func(*testing.T, error)
	}{
		{
			name: "successful update with all fields",
			request: UpdateBookRequest{
				ID:      "book-123",
				Name:    strPtr("Updated Book Name"),
				Genre:   strPtr("Updated Genre"),
				ISBN:    strPtr("978-1234567890"),
				Authors: []string{"author-1", "author-2"},
			},
			setupMocks: func(repo *mocks.MockRepository, cache *mocks.MockCache) {
				// Repository update succeeds
				repo.EXPECT().
					Update(mock.Anything, "book-123", mock.Anything).
					Return(nil).
					Once()

				// Cache update succeeds
				cache.EXPECT().
					Set(mock.Anything, "book-123", mock.Anything).
					Return(nil).
					Once()
			},
			expectError: false,
		},
		{
			name: "successful update with partial fields",
			request: UpdateBookRequest{
				ID:   "book-456",
				Name: strPtr("Only Name Updated"),
				// Genre, ISBN, Authors not provided
			},
			setupMocks: func(repo *mocks.MockRepository, cache *mocks.MockCache) {
				// Repository update succeeds
				repo.EXPECT().
					Update(mock.Anything, "book-456", mock.Anything).
					Return(nil).
					Once()

				// Cache update succeeds
				cache.EXPECT().
					Set(mock.Anything, "book-456", mock.Anything).
					Return(nil).
					Once()
			},
			expectError: false,
		},
		{
			name: "empty ID validation error",
			request: UpdateBookRequest{
				ID:   "",
				Name: strPtr("Some Book"),
			},
			setupMocks: func(repo *mocks.MockRepository, cache *mocks.MockCache) {
				// No mocks should be called
			},
			expectError: true,
			errorCheck: func(t *testing.T, err error) {
				testutil.AssertError(t, err)
				testutil.AssertStringContains(t, err.Error(), "Invalid input")
			},
		},
		{
			name: "book not found error",
			request: UpdateBookRequest{
				ID:   "non-existent-book",
				Name: strPtr("Updated Name"),
			},
			setupMocks: func(repo *mocks.MockRepository, cache *mocks.MockCache) {
				// Repository returns not found error
				repo.EXPECT().
					Update(mock.Anything, "non-existent-book", mock.Anything).
					Return(store.ErrorNotFound).
					Once()
			},
			expectError: true,
			errorCheck: func(t *testing.T, err error) {
				testutil.AssertError(t, err)
				testutil.AssertStringContains(t, err.Error(), "not found")
			},
		},
		{
			name: "repository error during update",
			request: UpdateBookRequest{
				ID:   "book-error",
				Name: strPtr("Updated Name"),
			},
			setupMocks: func(repo *mocks.MockRepository, cache *mocks.MockCache) {
				// Repository returns database error
				repo.EXPECT().
					Update(mock.Anything, "book-error", mock.Anything).
					Return(errors.ErrDatabase).
					Once()
			},
			expectError: true,
			errorCheck: func(t *testing.T, err error) {
				testutil.AssertError(t, err)
			},
		},
		{
			name: "cache update failure (non-critical, should succeed)",
			request: UpdateBookRequest{
				ID:   "book-cache-fail",
				Name: strPtr("Updated Name"),
			},
			setupMocks: func(repo *mocks.MockRepository, cache *mocks.MockCache) {
				// Repository update succeeds
				repo.EXPECT().
					Update(mock.Anything, "book-cache-fail", mock.Anything).
					Return(nil).
					Once()

				// Cache update fails (non-critical)
				cache.EXPECT().
					Set(mock.Anything, "book-cache-fail", mock.Anything).
					Return(errors.ErrCache).
					Once()
			},
			expectError: false, // Should succeed despite cache failure
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Setup mocks
			mockRepo := mocks.NewMockRepository(t)
			mockCache := mocks.NewMockCache(t)
			tt.setupMocks(mockRepo, mockCache)

			// Create use case
			uc := NewUpdateBookUseCase(mockRepo, mockCache)

			// Execute
			ctx := context.Background()
			err := uc.Execute(ctx, tt.request)

			// Assert
			if tt.expectError {
				testutil.AssertError(t, err)
				if tt.errorCheck != nil {
					tt.errorCheck(t, err)
				}
			} else {
				testutil.AssertNoError(t, err)
			}

			// Mocks verify expectations automatically
		})
	}
}
