package paymentops

import (
	"library-service/test/helpers"
	"library-service/test/builders"
	"library-service/internal/adapters/repository/mocks"
	"context"
	"testing"

	"github.com/stretchr/testify/mock"

	"library-service/internal/domain/payment"
	"library-service/pkg/errors"
)

func TestHandleCallbackUseCase_Execute(t *testing.T) {
	tests := []struct {
		name         string
		request      PaymentCallbackRequest
		setupMocks   func(*mocks.MockPaymentRepository)
		expectError  bool
		errorCheck   func(*testing.T, error)
		validateFunc func(*testing.T, HandleCallbackResponse)
	}{
		{
			name: "successful callback - payment completed",
			request: PaymentCallbackRequest{
				InvoiceID:     "invoice-123",
				TransactionID: "txn-abc123",
				Amount:        10000,
				Currency:      "KZT",
				Status:        "success",
				CardMask:      strPtr("****1234"),
				ApprovalCode:  strPtr("OK1234"),
			},
			setupMocks: func(repo *mocks.MockPaymentRepository) {
				// Payment exists and is processing (not pending - business rule)
				paymentEntity := validPayment()
				paymentEntity.InvoiceID = "invoice-123"
				paymentEntity.Status = payment.StatusProcessing // Changed from Pending

				repo.On("GetByInvoiceID", mock.Anything, "invoice-123").
					Return(paymentEntity, nil).
					Once()

				// Payment should be updated with completion status
				repo.On("Update", mock.Anything, "payment-123", mock.MatchedBy(func(p payment.Payment) bool {
					return p.Status == payment.StatusCompleted &&
						p.GatewayTransactionID != nil &&
						*p.GatewayTransactionID == "txn-abc123" &&
						p.CardMask != nil &&
						*p.CardMask == "****1234" &&
						p.CompletedAt != nil
				})).Return(nil).Once()
			},
			expectError: false,
			validateFunc: func(t *testing.T, resp HandleCallbackResponse) {
				helpers.AssertEqual(t, "payment-123", resp.PaymentID)
				helpers.AssertEqual(t, payment.StatusCompleted, resp.Status)
				helpers.AssertTrue(t, resp.Processed)
			},
		},
		{
			name: "payment not found by invoice ID",
			request: PaymentCallbackRequest{
				InvoiceID:     "non-existent",
				TransactionID: "txn-abc123",
				Amount:        10000,
				Currency:      "KZT",
				Status:        "success",
			},
			setupMocks: func(repo *mocks.MockPaymentRepository) {
				repo.On("GetByInvoiceID", mock.Anything, "non-existent").
					Return(payment.Payment{}, errors.ErrNotFound).
					Once()
			},
			expectError: true,
			errorCheck: func(t *testing.T, err error) {
				helpers.AssertError(t, err)
				helpers.AssertErrorContains(t, err.Error(), "not found")
			},
		},
		{
			name: "security check failed - amount mismatch",
			request: PaymentCallbackRequest{
				InvoiceID:     "invoice-123",
				TransactionID: "txn-abc123",
				Amount:        5000, // Different from payment amount (10000)
				Currency:      "KZT",
				Status:        "success",
			},
			setupMocks: func(repo *mocks.MockPaymentRepository) {
				paymentEntity := validPayment()
				paymentEntity.InvoiceID = "invoice-123"
				paymentEntity.Amount = 10000 // Different from callback
				paymentEntity.Status = payment.StatusPending

				repo.On("GetByInvoiceID", mock.Anything, "invoice-123").
					Return(paymentEntity, nil).
					Once()

				// No update should be called - validation fails
			},
			expectError: true,
			errorCheck: func(t *testing.T, err error) {
				helpers.AssertError(t, err)
				helpers.AssertErrorContains(t, err.Error(), "Validation failed")
			},
		},
		{
			name: "security check failed - currency mismatch",
			request: PaymentCallbackRequest{
				InvoiceID:     "invoice-123",
				TransactionID: "txn-abc123",
				Amount:        10000,
				Currency:      "USD", // Different from payment currency (KZT)
				Status:        "success",
			},
			setupMocks: func(repo *mocks.MockPaymentRepository) {
				paymentEntity := validPayment()
				paymentEntity.InvoiceID = "invoice-123"
				paymentEntity.Currency = "KZT" // Different from callback
				paymentEntity.Status = payment.StatusPending

				repo.On("GetByInvoiceID", mock.Anything, "invoice-123").
					Return(paymentEntity, nil).
					Once()

				// No update should be called - validation fails
			},
			expectError: true,
			errorCheck: func(t *testing.T, err error) {
				helpers.AssertError(t, err)
				helpers.AssertErrorContains(t, err.Error(), "Validation failed")
			},
		},
		{
			name: "idempotency - payment already completed",
			request: PaymentCallbackRequest{
				InvoiceID:     "invoice-123",
				TransactionID: "txn-abc123",
				Amount:        10000,
				Currency:      "KZT",
				Status:        "success",
			},
			setupMocks: func(repo *mocks.MockPaymentRepository) {
				// Payment is already completed
				paymentEntity := validPayment()
				paymentEntity.InvoiceID = "invoice-123"
				paymentEntity.Status = payment.StatusCompleted

				repo.On("GetByInvoiceID", mock.Anything, "invoice-123").
					Return(paymentEntity, nil).
					Once()

				// No update should be called - already in final state
			},
			expectError: false,
			validateFunc: func(t *testing.T, resp HandleCallbackResponse) {
				helpers.AssertEqual(t, "payment-123", resp.PaymentID)
				helpers.AssertEqual(t, payment.StatusCompleted, resp.Status)
				helpers.AssertFalse(t, resp.Processed) // Not processed, already final
			},
		},
		{
			name: "callback with failed status",
			request: PaymentCallbackRequest{
				InvoiceID:     "invoice-123",
				TransactionID: "txn-failed",
				Amount:        10000,
				Currency:      "KZT",
				Status:        "failed",
				ErrorCode:     strPtr("ERR_DECLINED"),
				ErrorMessage:  strPtr("Card declined"),
			},
			setupMocks: func(repo *mocks.MockPaymentRepository) {
				paymentEntity := validPayment()
				paymentEntity.InvoiceID = "invoice-123"
				paymentEntity.Status = payment.StatusPending

				repo.On("GetByInvoiceID", mock.Anything, "invoice-123").
					Return(paymentEntity, nil).
					Once()

				// Payment should be updated with failed status
				repo.On("Update", mock.Anything, "payment-123", mock.MatchedBy(func(p payment.Payment) bool {
					return p.Status == payment.StatusFailed &&
						p.ErrorCode != nil &&
						*p.ErrorCode == "ERR_DECLINED" &&
						p.ErrorMessage != nil &&
						*p.ErrorMessage == "Card declined"
				})).Return(nil).Once()
			},
			expectError: false,
			validateFunc: func(t *testing.T, resp HandleCallbackResponse) {
				helpers.AssertEqual(t, "payment-123", resp.PaymentID)
				helpers.AssertEqual(t, payment.StatusFailed, resp.Status)
				helpers.AssertTrue(t, resp.Processed)
			},
		},
		{
			name: "callback with cancelled status",
			request: PaymentCallbackRequest{
				InvoiceID:     "invoice-123",
				TransactionID: "txn-cancelled",
				Amount:        10000,
				Currency:      "KZT",
				Status:        "cancelled",
			},
			setupMocks: func(repo *mocks.MockPaymentRepository) {
				paymentEntity := validPayment()
				paymentEntity.InvoiceID = "invoice-123"
				paymentEntity.Status = payment.StatusPending

				repo.On("GetByInvoiceID", mock.Anything, "invoice-123").
					Return(paymentEntity, nil).
					Once()

				// Payment should be updated with cancelled status
				repo.On("Update", mock.Anything, "payment-123", mock.MatchedBy(func(p payment.Payment) bool {
					return p.Status == payment.StatusCancelled
				})).Return(nil).Once()
			},
			expectError: false,
			validateFunc: func(t *testing.T, resp HandleCallbackResponse) {
				helpers.AssertEqual(t, "payment-123", resp.PaymentID)
				helpers.AssertEqual(t, payment.StatusCancelled, resp.Status)
				helpers.AssertTrue(t, resp.Processed)
			},
		},
		{
			name: "invalid status transition - pending to completed",
			request: PaymentCallbackRequest{
				InvoiceID:     "invoice-123",
				TransactionID: "txn-abc123",
				Amount:        10000,
				Currency:      "KZT",
				Status:        "success", // Maps to completed
			},
			setupMocks: func(repo *mocks.MockPaymentRepository) {
				// Payment is pending - can't go directly to completed (must go through processing)
				paymentEntity := validPayment()
				paymentEntity.InvoiceID = "invoice-123"
				paymentEntity.Status = payment.StatusPending

				repo.On("GetByInvoiceID", mock.Anything, "invoice-123").
					Return(paymentEntity, nil).
					Once()

				// No update should be called - transition is invalid
			},
			expectError: true,
			errorCheck: func(t *testing.T, err error) {
				helpers.AssertError(t, err)
				helpers.AssertErrorContains(t, err.Error(), "Validation failed")
			},
		},
		{
			name: "repository update error",
			request: PaymentCallbackRequest{
				InvoiceID:     "invoice-123",
				TransactionID: "txn-abc123",
				Amount:        10000,
				Currency:      "KZT",
				Status:        "success",
			},
			setupMocks: func(repo *mocks.MockPaymentRepository) {
				paymentEntity := validPayment()
				paymentEntity.InvoiceID = "invoice-123"
				paymentEntity.Status = payment.StatusProcessing // Changed from Pending

				repo.On("GetByInvoiceID", mock.Anything, "invoice-123").
					Return(paymentEntity, nil).
					Once()

				// Update fails
				repo.On("Update", mock.Anything, "payment-123", mock.Anything).
					Return(errors.ErrDatabase).
					Once()
			},
			expectError: true,
			errorCheck: func(t *testing.T, err error) {
				helpers.AssertError(t, err)
			},
		},
		{
			name: "callback with gateway response JSON",
			request: PaymentCallbackRequest{
				InvoiceID:     "invoice-123",
				TransactionID: "txn-abc123",
				Amount:        10000,
				Currency:      "KZT",
				Status:        "success",
				GatewayResponse: map[string]interface{}{
					"resultCode": "0",
					"message":    "Success",
					"details": map[string]interface{}{
						"authCode": "123456",
					},
				},
			},
			setupMocks: func(repo *mocks.MockPaymentRepository) {
				paymentEntity := validPayment()
				paymentEntity.InvoiceID = "invoice-123"
				paymentEntity.Status = payment.StatusProcessing // Changed from Pending

				repo.On("GetByInvoiceID", mock.Anything, "invoice-123").
					Return(paymentEntity, nil).
					Once()

				// Gateway response should be stored as JSON
				repo.On("Update", mock.Anything, "payment-123", mock.MatchedBy(func(p payment.Payment) bool {
					return p.GatewayResponse != nil &&
						*p.GatewayResponse != ""
				})).Return(nil).Once()
			},
			expectError: false,
			validateFunc: func(t *testing.T, resp HandleCallbackResponse) {
				helpers.AssertEqual(t, "payment-123", resp.PaymentID)
				helpers.AssertEqual(t, payment.StatusCompleted, resp.Status)
				helpers.AssertTrue(t, resp.Processed)
			},
		},
		{
			name: "idempotency - payment refunded",
			request: PaymentCallbackRequest{
				InvoiceID:     "invoice-123",
				TransactionID: "txn-abc123",
				Amount:        10000,
				Currency:      "KZT",
				Status:        "success",
			},
			setupMocks: func(repo *mocks.MockPaymentRepository) {
				// Payment is already refunded (final state)
				paymentEntity := validPayment()
				paymentEntity.InvoiceID = "invoice-123"
				paymentEntity.Status = payment.StatusRefunded

				repo.On("GetByInvoiceID", mock.Anything, "invoice-123").
					Return(paymentEntity, nil).
					Once()

				// No update should be called - already in final state
			},
			expectError: false,
			validateFunc: func(t *testing.T, resp HandleCallbackResponse) {
				helpers.AssertEqual(t, "payment-123", resp.PaymentID)
				helpers.AssertEqual(t, payment.StatusRefunded, resp.Status)
				helpers.AssertFalse(t, resp.Processed) // Not processed, already final
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Setup mocks
			mockRepo := new(mocks.MockPaymentRepository)
			tt.setupMocks(mockRepo)

			// Create real payment service
			paymentService := payment.NewService()

			// Create use case
			uc := NewHandleCallbackUseCase(mockRepo, paymentService)

			// Execute
			ctx := helpers.TestContext(t)
			result, err := uc.Execute(ctx, tt.request)

			// Assert
			if tt.expectError {
				helpers.AssertError(t, err)
				if tt.errorCheck != nil {
					tt.errorCheck(t, err)
				}
			} else {
				helpers.AssertNoError(t, err)
				if tt.validateFunc != nil {
					tt.validateFunc(t, result)
				}
			}

			// Verify all expectations were met
			mockRepo.AssertExpectations(t)
		})
	}
}
