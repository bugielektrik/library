package paymentops

import (
	"library-service/test/helpers"
	"library-service/test/builders"
	"library-service/internal/adapters/repository/mocks"
	"context"
	"testing"
	"time"

	"github.com/stretchr/testify/mock"

	"library-service/internal/domain/payment"
	"library-service/pkg/errors"
)

// Mock for payment.Gateway interface
type mockPaymentGatewayChecker struct {
	mock.Mock
}

func (m *mockPaymentGatewayChecker) GetAuthToken(ctx context.Context) (string, error) {
	args := m.Called(ctx)
	return args.String(0), args.Error(1)
}

func (m *mockPaymentGatewayChecker) CheckPaymentStatus(ctx context.Context, invoiceID string) (*payment.GatewayStatusResponse, error) {
	args := m.Called(ctx, invoiceID)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*payment.GatewayStatusResponse), args.Error(1)
}

func (m *mockPaymentGatewayChecker) RefundPayment(ctx context.Context, transactionID string, amount *float64, externalID string) error {
	args := m.Called(ctx, transactionID, amount, externalID)
	return args.Error(0)
}

func (m *mockPaymentGatewayChecker) CancelPayment(ctx context.Context, transactionID string) error {
	args := m.Called(ctx, transactionID)
	return args.Error(0)
}

func (m *mockPaymentGatewayChecker) ChargeCard(ctx context.Context, req *payment.CardChargeRequest) (*payment.CardChargeResponse, error) {
	args := m.Called(ctx, req)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*payment.CardChargeResponse), args.Error(1)
}

// Helper function to create a valid payment entity
func validPayment() payment.Payment {
	now := time.Now()
	expiresAt := now.Add(30 * time.Minute)

	return payment.Payment{
		ID:            "payment-123",
		InvoiceID:     "invoice-123",
		MemberID:      "member-123",
		Amount:        10000,
		Currency:      "KZT",
		Status:        payment.StatusPending,
		PaymentMethod: payment.PaymentMethodCard,
		PaymentType:   payment.PaymentTypeFine,
		CreatedAt:     now,
		UpdatedAt:     now,
		ExpiresAt:     expiresAt,
	}
}

func TestVerifyPaymentUseCase_Execute(t *testing.T) {
	tests := []struct {
		name         string
		request      VerifyPaymentRequest
		setupMocks   func(*mocks.MockPaymentRepository, *mockPaymentGatewayChecker)
		expectError  bool
		errorCheck   func(*testing.T, error)
		validateFunc func(*testing.T, VerifyPaymentResponse)
	}{
		{
			name: "successful verification - completed payment",
			request: VerifyPaymentRequest{
				PaymentID: "payment-123",
			},
			setupMocks: func(repo *mocks.MockPaymentRepository, gateway *mockPaymentGatewayChecker) {
				// Payment is already completed, no gateway check needed
				paymentEntity := validPayment()
				paymentEntity.Status = payment.StatusCompleted
				transactionID := "txn-abc123"
				paymentEntity.GatewayTransactionID = &transactionID

				repo.On("GetByID", mock.Anything, "payment-123").
					Return(paymentEntity, nil).
					Once()
			},
			expectError: false,
			validateFunc: func(t *testing.T, resp VerifyPaymentResponse) {
				helpers.AssertEqual(t, "payment-123", resp.PaymentID)
				helpers.AssertEqual(t, "invoice-123", resp.InvoiceID)
				helpers.AssertEqual(t, payment.StatusCompleted, resp.Status)
				helpers.AssertEqual(t, int64(10000), resp.Amount)
				helpers.AssertEqual(t, "KZT", resp.Currency)
			},
		},
		{
			name: "payment not found",
			request: VerifyPaymentRequest{
				PaymentID: "non-existent",
			},
			setupMocks: func(repo *mocks.MockPaymentRepository, gateway *mockPaymentGatewayChecker) {
				repo.On("GetByID", mock.Anything, "non-existent").
					Return(payment.Payment{}, errors.ErrNotFound).
					Once()
			},
			expectError: true,
			errorCheck: func(t *testing.T, err error) {
				helpers.AssertError(t, err)
				helpers.AssertErrorContains(t, err.Error(), "not found")
			},
		},
		{
			name: "payment expired - status updated to failed",
			request: VerifyPaymentRequest{
				PaymentID: "payment-expired",
			},
			setupMocks: func(repo *mocks.MockPaymentRepository, gateway *mockPaymentGatewayChecker) {
				// Payment is pending but expired
				paymentEntity := validPayment()
				paymentEntity.ID = "payment-expired"
				paymentEntity.Status = payment.StatusPending
				paymentEntity.ExpiresAt = time.Now().Add(-1 * time.Hour) // Expired 1 hour ago

				repo.On("GetByID", mock.Anything, "payment-expired").
					Return(paymentEntity, nil).
					Once()

				// Status should be updated to failed
				repo.On("UpdateStatus", mock.Anything, "payment-expired", payment.StatusFailed).
					Return(nil).
					Once()
			},
			expectError: false,
			validateFunc: func(t *testing.T, resp VerifyPaymentResponse) {
				helpers.AssertEqual(t, "payment-expired", resp.PaymentID)
				helpers.AssertEqual(t, payment.StatusFailed, resp.Status)
			},
		},
		{
			name: "gateway status update - success",
			request: VerifyPaymentRequest{
				PaymentID: "payment-pending",
			},
			setupMocks: func(repo *mocks.MockPaymentRepository, gateway *mockPaymentGatewayChecker) {
				// Payment is pending
				paymentEntity := validPayment()
				paymentEntity.ID = "payment-pending"
				paymentEntity.Status = payment.StatusPending

				repo.On("GetByID", mock.Anything, "payment-pending").
					Return(paymentEntity, nil).
					Once()

				// Gateway returns success status
				gatewayResp := &payment.GatewayStatusResponse{
					ResultCode:    "0",
					ResultMessage: "Success",
					Transaction: payment.GatewayTransactionDetails{
						ID:           "txn-xyz789",
						InvoiceID:    "invoice-123",
						Amount:       10000,
						Currency:     "KZT",
						Status:       "Success",
						CardMask:     "****1234",
						ApprovalCode: "OK1234",
						Reference:    "ref-123",
					},
				}
				gateway.On("CheckPaymentStatus", mock.Anything, "invoice-123").
					Return(gatewayResp, nil).
					Once()

				// Status should be updated to completed
				repo.On("UpdateStatus", mock.Anything, "payment-pending", payment.StatusCompleted).
					Return(nil).
					Once()

				// Additional details should be updated
				repo.On("Update", mock.Anything, "payment-pending", mock.MatchedBy(func(p payment.Payment) bool {
					return p.GatewayTransactionID != nil &&
						*p.GatewayTransactionID == "txn-xyz789" &&
						p.CardMask != nil &&
						*p.CardMask == "****1234"
				})).Return(nil).Once()

				// Reload payment after update
				updatedPayment := paymentEntity
				updatedPayment.Status = payment.StatusCompleted
				txnID := "txn-xyz789"
				updatedPayment.GatewayTransactionID = &txnID
				cardMask := "****1234"
				updatedPayment.CardMask = &cardMask

				repo.On("GetByID", mock.Anything, "payment-pending").
					Return(updatedPayment, nil).
					Once()
			},
			expectError: false,
			validateFunc: func(t *testing.T, resp VerifyPaymentResponse) {
				helpers.AssertEqual(t, "payment-pending", resp.PaymentID)
				helpers.AssertEqual(t, payment.StatusCompleted, resp.Status)
			},
		},
		{
			name: "gateway status update - failed",
			request: VerifyPaymentRequest{
				PaymentID: "payment-to-fail",
			},
			setupMocks: func(repo *mocks.MockPaymentRepository, gateway *mockPaymentGatewayChecker) {
				// Payment is processing
				paymentEntity := validPayment()
				paymentEntity.ID = "payment-to-fail"
				paymentEntity.Status = payment.StatusProcessing

				repo.On("GetByID", mock.Anything, "payment-to-fail").
					Return(paymentEntity, nil).
					Once()

				// Gateway returns failed status
				gatewayResp := &payment.GatewayStatusResponse{
					ResultCode:    "1",
					ResultMessage: "Failed",
					Transaction: payment.GatewayTransactionDetails{
						ID:        "txn-failed",
						InvoiceID: "invoice-123",
						Amount:    10000,
						Currency:  "KZT",
						Status:    "Failed",
					},
				}
				gateway.On("CheckPaymentStatus", mock.Anything, "invoice-123").
					Return(gatewayResp, nil).
					Once()

				// Status should be updated to failed
				repo.On("UpdateStatus", mock.Anything, "payment-to-fail", payment.StatusFailed).
					Return(nil).
					Once()

				// Transaction details should be saved
				repo.On("Update", mock.Anything, "payment-to-fail", mock.MatchedBy(func(p payment.Payment) bool {
					return p.GatewayTransactionID != nil && *p.GatewayTransactionID == "txn-failed"
				})).Return(nil).Once()

				// Reload payment after update
				updatedPayment := paymentEntity
				updatedPayment.Status = payment.StatusFailed
				transactionID := "txn-failed"
				updatedPayment.GatewayTransactionID = &transactionID

				repo.On("GetByID", mock.Anything, "payment-to-fail").
					Return(updatedPayment, nil).
					Once()
			},
			expectError: false,
			validateFunc: func(t *testing.T, resp VerifyPaymentResponse) {
				helpers.AssertEqual(t, "payment-to-fail", resp.PaymentID)
				helpers.AssertEqual(t, payment.StatusFailed, resp.Status)
				helpers.AssertNotNil(t, resp.GatewayTransactionID)
				helpers.AssertEqual(t, "txn-failed", *resp.GatewayTransactionID)
			},
		},
		{
			name: "gateway check error - return current status",
			request: VerifyPaymentRequest{
				PaymentID: "payment-gateway-error",
			},
			setupMocks: func(repo *mocks.MockPaymentRepository, gateway *mockPaymentGatewayChecker) {
				// Payment is pending
				paymentEntity := validPayment()
				paymentEntity.ID = "payment-gateway-error"
				paymentEntity.Status = payment.StatusPending

				repo.On("GetByID", mock.Anything, "payment-gateway-error").
					Return(paymentEntity, nil).
					Once()

				// Gateway check fails
				gateway.On("CheckPaymentStatus", mock.Anything, "invoice-123").
					Return(nil, errors.ErrPaymentGateway).
					Once()

				// No update calls - just return current status
			},
			expectError: false,
			validateFunc: func(t *testing.T, resp VerifyPaymentResponse) {
				helpers.AssertEqual(t, "payment-gateway-error", resp.PaymentID)
				helpers.AssertEqual(t, payment.StatusPending, resp.Status)
			},
		},
		// Note: "gateway response without transaction data" test removed
		// The typed domain interface (payment.GatewayStatusResponse) enforces that
		// Transaction is always present (not a pointer), so this edge case can't occur
		{
			name: "already completed - no gateway check",
			request: VerifyPaymentRequest{
				PaymentID: "payment-completed",
			},
			setupMocks: func(repo *mocks.MockPaymentRepository, gateway *mockPaymentGatewayChecker) {
				// Payment is already completed
				paymentEntity := validPayment()
				paymentEntity.ID = "payment-completed"
				paymentEntity.Status = payment.StatusCompleted

				repo.On("GetByID", mock.Anything, "payment-completed").
					Return(paymentEntity, nil).
					Once()

				// Gateway check should NOT be called for completed payment
			},
			expectError: false,
			validateFunc: func(t *testing.T, resp VerifyPaymentResponse) {
				helpers.AssertEqual(t, "payment-completed", resp.PaymentID)
				helpers.AssertEqual(t, payment.StatusCompleted, resp.Status)
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Setup mocks
			mockRepo := new(mocks.MockPaymentRepository)
			mockGateway := new(mockPaymentGatewayChecker)
			tt.setupMocks(mockRepo, mockGateway)

			// Create real payment service
			paymentService := payment.NewService()

			// Create use case
			uc := NewVerifyPaymentUseCase(mockRepo, paymentService, mockGateway)

			// Execute
			ctx := helpers.TestContext(t)
			result, err := uc.Execute(ctx, tt.request)

			// Assert
			if tt.expectError {
				helpers.AssertError(t, err)
				if tt.errorCheck != nil {
					tt.errorCheck(t, err)
				}
			} else {
				helpers.AssertNoError(t, err)
				if tt.validateFunc != nil {
					tt.validateFunc(t, result)
				}
			}

			// Verify all expectations were met
			mockRepo.AssertExpectations(t)
			mockGateway.AssertExpectations(t)
		})
	}
}
