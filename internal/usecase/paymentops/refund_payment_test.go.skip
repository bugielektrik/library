package paymentops

import (
	"library-service/test/helpers"
	"library-service/test/builders"
	"library-service/internal/adapters/repository/mocks"
	"context"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"

	"library-service/internal/domain/payment"
	"library-service/pkg/errors"
)

func TestRefundPaymentUseCase_Execute(t *testing.T) {
	// Helper to create pointer
	int64Ptr := func(i int64) *int64 {
		return &i
	}

	tests := []struct {
		name         string
		request      RefundPaymentRequest
		setupMocks   func(*mocks.MockPaymentRepository, *mockPaymentGateway)
		wantErr      bool
		wantErrType  error
		validateResp func(*testing.T, RefundPaymentResponse)
	}{
		{
			name: "successfully refund completed payment (full refund)",
			request: RefundPaymentRequest{
				PaymentID: "payment-1",
				MemberID:  "member-1",
				IsAdmin:   true,
				Reason:    "Customer request",
			},
			setupMocks: func(repo *mocks.MockPaymentRepository, gateway *mockPaymentGateway) {
				txnID := "txn-123"
				paymentEntity := payment.Payment{
					ID:                   "payment-1",
					InvoiceID:            "inv-1",
					MemberID:             "member-1",
					Amount:               10000,
					Currency:             "KZT",
					Status:               payment.StatusCompleted,
					GatewayTransactionID: &txnID,
				}

				repo.On("GetByID", mock.Anything, "payment-1").
					Return(paymentEntity, nil)

				gateway.On("RefundPayment", mock.Anything, txnID, (*float64)(nil), "payment-1").
					Return(nil)

				repo.On("UpdateStatus", mock.Anything, "payment-1", payment.StatusRefunded).
					Return(nil)
			},
			wantErr: false,
			validateResp: func(t *testing.T, resp RefundPaymentResponse) {
				assert.Equal(t, "payment-1", resp.PaymentID)
				assert.Equal(t, payment.StatusRefunded, resp.Status)
				assert.Equal(t, int64(10000), resp.Amount)
				assert.Equal(t, "KZT", resp.Currency)
				assert.NotZero(t, resp.RefundedAt)
			},
		},
		{
			name: "successfully refund with partial amount",
			request: RefundPaymentRequest{
				PaymentID:    "payment-2",
				MemberID:     "admin",
				IsAdmin:      true,
				Reason:       "Partial refund requested",
				RefundAmount: int64Ptr(5000),
			},
			setupMocks: func(repo *mocks.MockPaymentRepository, gateway *mockPaymentGateway) {
				txnID := "txn-456"
				paymentEntity := payment.Payment{
					ID:                   "payment-2",
					InvoiceID:            "inv-2",
					MemberID:             "member-2",
					Amount:               10000,
					Currency:             "KZT",
					Status:               payment.StatusCompleted,
					GatewayTransactionID: &txnID,
				}

				repo.On("GetByID", mock.Anything, "payment-2").
					Return(paymentEntity, nil)

				// Gateway expects partial amount as float64 pointer
				gateway.On("RefundPayment", mock.Anything, txnID, mock.MatchedBy(func(amt *float64) bool {
					return amt != nil && *amt == 5000.0
				}), "payment-2").
					Return(nil)

				repo.On("UpdateStatus", mock.Anything, "payment-2", payment.StatusRefunded).
					Return(nil)
			},
			wantErr: false,
			validateResp: func(t *testing.T, resp RefundPaymentResponse) {
				assert.Equal(t, "payment-2", resp.PaymentID)
				assert.Equal(t, int64(5000), resp.Amount) // Partial amount
			},
		},
		{
			name: "member successfully refunds their own payment",
			request: RefundPaymentRequest{
				PaymentID: "payment-3",
				MemberID:  "member-3",
				IsAdmin:   false,
				Reason:    "Changed mind",
			},
			setupMocks: func(repo *mocks.MockPaymentRepository, gateway *mockPaymentGateway) {
				txnID := "txn-789"
				paymentEntity := payment.Payment{
					ID:                   "payment-3",
					InvoiceID:            "inv-3",
					MemberID:             "member-3",
					Amount:               20000,
					Currency:             "KZT",
					Status:               payment.StatusCompleted,
					GatewayTransactionID: &txnID,
				}

				repo.On("GetByID", mock.Anything, "payment-3").
					Return(paymentEntity, nil)

				gateway.On("RefundPayment", mock.Anything, txnID, (*float64)(nil), "payment-3").
					Return(nil)

				repo.On("UpdateStatus", mock.Anything, "payment-3", payment.StatusRefunded).
					Return(nil)
			},
			wantErr: false,
			validateResp: func(t *testing.T, resp RefundPaymentResponse) {
				assert.Equal(t, "payment-3", resp.PaymentID)
				assert.Equal(t, int64(20000), resp.Amount)
			},
		},
		{
			name: "successfully refund without gateway transaction ID",
			request: RefundPaymentRequest{
				PaymentID: "payment-manual",
				MemberID:  "admin",
				IsAdmin:   true,
				Reason:    "Manual refund",
			},
			setupMocks: func(repo *mocks.MockPaymentRepository, gateway *mockPaymentGateway) {
				paymentEntity := payment.Payment{
					ID:                   "payment-manual",
					InvoiceID:            "inv-manual",
					MemberID:             "member-1",
					Amount:               15000,
					Currency:             "KZT",
					Status:               payment.StatusCompleted,
					GatewayTransactionID: nil, // No gateway transaction
				}

				repo.On("GetByID", mock.Anything, "payment-manual").
					Return(paymentEntity, nil)

				// Gateway refund should NOT be called
				// (no mock setup for gateway.RefundPayment)

				repo.On("UpdateStatus", mock.Anything, "payment-manual", payment.StatusRefunded).
					Return(nil)
			},
			wantErr: false,
			validateResp: func(t *testing.T, resp RefundPaymentResponse) {
				assert.Equal(t, "payment-manual", resp.PaymentID)
				assert.Equal(t, int64(15000), resp.Amount)
			},
		},
		{
			name: "error - payment not found",
			request: RefundPaymentRequest{
				PaymentID: "nonexistent",
				MemberID:  "admin",
				IsAdmin:   true,
				Reason:    "Test",
			},
			setupMocks: func(repo *mocks.MockPaymentRepository, gateway *mockPaymentGateway) {
				repo.On("GetByID", mock.Anything, "nonexistent").
					Return(payment.Payment{}, errors.ErrNotFound)
			},
			wantErr:     true,
			wantErrType: errors.ErrPaymentNotFound,
		},
		{
			name: "error - member trying to refund someone else's payment",
			request: RefundPaymentRequest{
				PaymentID: "payment-4",
				MemberID:  "wrong-member",
				IsAdmin:   false,
				Reason:    "Test",
			},
			setupMocks: func(repo *mocks.MockPaymentRepository, gateway *mockPaymentGateway) {
				paymentEntity := payment.Payment{
					ID:        "payment-4",
					InvoiceID: "inv-4",
					MemberID:  "actual-member",
					Amount:    10000,
					Currency:  "KZT",
					Status:    payment.StatusCompleted,
				}

				repo.On("GetByID", mock.Anything, "payment-4").
					Return(paymentEntity, nil)
			},
			wantErr:     true,
			wantErrType: errors.ErrNotFound,
		},
		{
			name: "error - cannot refund non-completed payment",
			request: RefundPaymentRequest{
				PaymentID: "payment-pending",
				MemberID:  "admin",
				IsAdmin:   true,
				Reason:    "Test",
			},
			setupMocks: func(repo *mocks.MockPaymentRepository, gateway *mockPaymentGateway) {
				paymentEntity := payment.Payment{
					ID:        "payment-pending",
					InvoiceID: "inv-pending",
					MemberID:  "member-1",
					Amount:    10000,
					Currency:  "KZT",
					Status:    payment.StatusPending,
				}

				repo.On("GetByID", mock.Anything, "payment-pending").
					Return(paymentEntity, nil)
			},
			wantErr:     true,
			wantErrType: errors.ErrInvalidPaymentStatus,
		},
		{
			name: "error - invalid refund amount - zero",
			request: RefundPaymentRequest{
				PaymentID:    "payment-5",
				MemberID:     "admin",
				IsAdmin:      true,
				Reason:       "Test",
				RefundAmount: int64Ptr(0),
			},
			setupMocks: func(repo *mocks.MockPaymentRepository, gateway *mockPaymentGateway) {
				paymentEntity := payment.Payment{
					ID:        "payment-5",
					InvoiceID: "inv-5",
					MemberID:  "member-1",
					Amount:    10000,
					Currency:  "KZT",
					Status:    payment.StatusCompleted,
				}

				repo.On("GetByID", mock.Anything, "payment-5").
					Return(paymentEntity, nil)
			},
			wantErr:     true,
			wantErrType: errors.ErrValidation,
		},
		{
			name: "error - refund amount exceeds payment amount",
			request: RefundPaymentRequest{
				PaymentID:    "payment-6",
				MemberID:     "admin",
				IsAdmin:      true,
				Reason:       "Test",
				RefundAmount: int64Ptr(15000),
			},
			setupMocks: func(repo *mocks.MockPaymentRepository, gateway *mockPaymentGateway) {
				paymentEntity := payment.Payment{
					ID:        "payment-6",
					InvoiceID: "inv-6",
					MemberID:  "member-1",
					Amount:    10000,
					Currency:  "KZT",
					Status:    payment.StatusCompleted,
				}

				repo.On("GetByID", mock.Anything, "payment-6").
					Return(paymentEntity, nil)
			},
			wantErr:     true,
			wantErrType: errors.ErrValidation,
		},
		{
			name: "error - gateway refund fails",
			request: RefundPaymentRequest{
				PaymentID: "payment-7",
				MemberID:  "admin",
				IsAdmin:   true,
				Reason:    "Test",
			},
			setupMocks: func(repo *mocks.MockPaymentRepository, gateway *mockPaymentGateway) {
				txnID := "txn-failed"
				paymentEntity := payment.Payment{
					ID:                   "payment-7",
					InvoiceID:            "inv-7",
					MemberID:             "member-1",
					Amount:               10000,
					Currency:             "KZT",
					Status:               payment.StatusCompleted,
					GatewayTransactionID: &txnID,
				}

				repo.On("GetByID", mock.Anything, "payment-7").
					Return(paymentEntity, nil)

				gateway.On("RefundPayment", mock.Anything, txnID, (*float64)(nil), "payment-7").
					Return(errors.ErrPaymentGateway.WithDetail("reason", "gateway error"))
			},
			wantErr:     true,
			wantErrType: errors.ErrPaymentGateway,
		},
		{
			name: "error - database error on UpdateStatus",
			request: RefundPaymentRequest{
				PaymentID: "payment-8",
				MemberID:  "admin",
				IsAdmin:   true,
				Reason:    "Test",
			},
			setupMocks: func(repo *mocks.MockPaymentRepository, gateway *mockPaymentGateway) {
				txnID := "txn-db-error"
				paymentEntity := payment.Payment{
					ID:                   "payment-8",
					InvoiceID:            "inv-8",
					MemberID:             "member-1",
					Amount:               10000,
					Currency:             "KZT",
					Status:               payment.StatusCompleted,
					GatewayTransactionID: &txnID,
				}

				repo.On("GetByID", mock.Anything, "payment-8").
					Return(paymentEntity, nil)

				gateway.On("RefundPayment", mock.Anything, txnID, (*float64)(nil), "payment-8").
					Return(nil)

				repo.On("UpdateStatus", mock.Anything, "payment-8", payment.StatusRefunded).
					Return(errors.ErrDatabase)
			},
			wantErr:     true,
			wantErrType: errors.ErrDatabase,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Setup
			mockRepo := new(mocks.MockPaymentRepository)
			mockGateway := new(mockPaymentGateway)
			tt.setupMocks(mockRepo, mockGateway)

			// Use real domain service
			service := payment.NewService()
			uc := NewRefundPaymentUseCase(mockRepo, service, mockGateway)
			ctx := helpers.TestContext(t)

			// Execute
			result, err := uc.Execute(ctx, tt.request)

			// Assert error
			if tt.wantErr {
				assert.Error(t, err)
				if tt.wantErrType != nil {
					assert.ErrorIs(t, err, tt.wantErrType)
				}
			} else {
				assert.NoError(t, err)

				// Run custom validation if provided
				if tt.validateResp != nil {
					tt.validateResp(t, result)
				}
			}

			// Verify mock expectations
			mockRepo.AssertExpectations(t)
			mockGateway.AssertExpectations(t)
		})
	}
}
