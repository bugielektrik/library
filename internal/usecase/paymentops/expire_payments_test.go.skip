package paymentops

import (
	"library-service/test/helpers"
	"library-service/test/builders"
	"library-service/internal/adapters/repository/mocks"
	"context"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"

	"library-service/internal/domain/payment"
	"library-service/pkg/errors"
)

func TestExpirePaymentsUseCase_Execute(t *testing.T) {
	now := time.Now()
	expiredTime := now.Add(-1 * time.Hour) // 1 hour ago

	tests := []struct {
		name             string
		request          ExpirePaymentsRequest
		setupMocks       func(*mocks.MockPaymentRepository)
		wantErr          bool
		wantExpiredCount int
		wantFailedCount  int
		wantErrorsCount  int
	}{
		{
			name: "successfully expire multiple payments",
			request: ExpirePaymentsRequest{
				BatchSize: 0, // No limit
			},
			setupMocks: func(repo *mocks.MockPaymentRepository) {
				// Pending payments
				pendingPayment1 := payment.Payment{
					ID:        "payment-1",
					InvoiceID: "inv-1",
					MemberID:  "member-1",
					Amount:    10000,
					Currency:  "KZT",
					Status:    payment.StatusPending,
					ExpiresAt: expiredTime, // Expired (1 hour ago)
					CreatedAt: expiredTime.Add(-10 * time.Minute),
				}
				pendingPayment2 := payment.Payment{
					ID:        "payment-2",
					InvoiceID: "inv-2",
					MemberID:  "member-1",
					Amount:    5000,
					Currency:  "KZT",
					Status:    payment.StatusPending,
					ExpiresAt: now.Add(1 * time.Hour), // Not expired
					CreatedAt: now,
				}

				// Processing payments
				processingPayment1 := payment.Payment{
					ID:        "payment-3",
					InvoiceID: "inv-3",
					MemberID:  "member-2",
					Amount:    15000,
					Currency:  "KZT",
					Status:    payment.StatusProcessing,
					ExpiresAt: expiredTime, // Expired (1 hour ago)
					CreatedAt: expiredTime.Add(-5 * time.Minute),
				}

				repo.On("ListByStatus", mock.Anything, payment.StatusPending).
					Return([]payment.Payment{pendingPayment1, pendingPayment2}, nil)

				repo.On("ListByStatus", mock.Anything, payment.StatusProcessing).
					Return([]payment.Payment{processingPayment1}, nil)

				// payment-1: expired - service will detect this
				repo.On("UpdateStatus", mock.Anything, "payment-1", payment.StatusFailed).Return(nil)

				// payment-2: not expired - service will skip this

				// payment-3: expired - service will detect this
				repo.On("UpdateStatus", mock.Anything, "payment-3", payment.StatusFailed).Return(nil)
			},
			wantErr:          false,
			wantExpiredCount: 2,
			wantFailedCount:  0,
			wantErrorsCount:  0,
		},
		{
			name: "successfully expire with batch size limit",
			request: ExpirePaymentsRequest{
				BatchSize: 1, // Only expire 1 payment
			},
			setupMocks: func(repo *mocks.MockPaymentRepository) {
				pendingPayment1 := payment.Payment{
					ID:        "payment-1",
					InvoiceID: "inv-1",
					Status:    payment.StatusPending,
					ExpiresAt: expiredTime, // Expired
				}
				pendingPayment2 := payment.Payment{
					ID:        "payment-2",
					InvoiceID: "inv-2",
					Status:    payment.StatusPending,
					ExpiresAt: expiredTime, // Expired
				}

				repo.On("ListByStatus", mock.Anything, payment.StatusPending).
					Return([]payment.Payment{pendingPayment1, pendingPayment2}, nil)

				repo.On("ListByStatus", mock.Anything, payment.StatusProcessing).
					Return([]payment.Payment{}, nil)

				// Both expired, but only first one should be processed due to batch size
				repo.On("UpdateStatus", mock.Anything, "payment-1", payment.StatusFailed).Return(nil)

				// payment-2 should not be processed due to batch size limit
			},
			wantErr:          false,
			wantExpiredCount: 1, // Only 1 due to batch size
			wantFailedCount:  0,
			wantErrorsCount:  0,
		},
		{
			name: "no payments to expire",
			request: ExpirePaymentsRequest{
				BatchSize: 0,
			},
			setupMocks: func(repo *mocks.MockPaymentRepository) {
				pendingPayment := payment.Payment{
					ID:        "payment-1",
					Status:    payment.StatusPending,
					ExpiresAt: now.Add(1 * time.Hour), // Not expired
				}

				repo.On("ListByStatus", mock.Anything, payment.StatusPending).
					Return([]payment.Payment{pendingPayment}, nil)

				repo.On("ListByStatus", mock.Anything, payment.StatusProcessing).
					Return([]payment.Payment{}, nil)

				// Not expired - service will skip this
			},
			wantErr:          false,
			wantExpiredCount: 0,
			wantFailedCount:  0,
			wantErrorsCount:  0,
		},
		{
			name: "error listing pending payments",
			request: ExpirePaymentsRequest{
				BatchSize: 0,
			},
			setupMocks: func(repo *mocks.MockPaymentRepository) {
				repo.On("ListByStatus", mock.Anything, payment.StatusPending).
					Return([]payment.Payment{}, errors.ErrDatabase)
			},
			wantErr:          true,
			wantExpiredCount: 0,
			wantFailedCount:  1,
			wantErrorsCount:  1,
		},
		{
			name: "error listing processing payments",
			request: ExpirePaymentsRequest{
				BatchSize: 0,
			},
			setupMocks: func(repo *mocks.MockPaymentRepository) {
				repo.On("ListByStatus", mock.Anything, payment.StatusPending).
					Return([]payment.Payment{}, nil)

				repo.On("ListByStatus", mock.Anything, payment.StatusProcessing).
					Return([]payment.Payment{}, errors.ErrDatabase)
			},
			wantErr:          true,
			wantExpiredCount: 0,
			wantFailedCount:  1,
			wantErrorsCount:  1,
		},
		{
			name: "partial failures - some payments fail to update",
			request: ExpirePaymentsRequest{
				BatchSize: 0,
			},
			setupMocks: func(repo *mocks.MockPaymentRepository) {
				pendingPayment1 := payment.Payment{
					ID:        "payment-1",
					Status:    payment.StatusPending,
					ExpiresAt: expiredTime, // Expired
				}
				pendingPayment2 := payment.Payment{
					ID:        "payment-2",
					Status:    payment.StatusPending,
					ExpiresAt: expiredTime, // Expired
				}

				repo.On("ListByStatus", mock.Anything, payment.StatusPending).
					Return([]payment.Payment{pendingPayment1, pendingPayment2}, nil)

				repo.On("ListByStatus", mock.Anything, payment.StatusProcessing).
					Return([]payment.Payment{}, nil)

				// payment-1: expired, updates successfully
				repo.On("UpdateStatus", mock.Anything, "payment-1", payment.StatusFailed).Return(nil)

				// payment-2: expired, but fails to update
				repo.On("UpdateStatus", mock.Anything, "payment-2", payment.StatusFailed).Return(errors.ErrDatabase)
			},
			wantErr:          false, // Use case doesn't return error for partial failures
			wantExpiredCount: 1,
			wantFailedCount:  1,
			wantErrorsCount:  1,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Setup
			mockRepo := new(mocks.MockPaymentRepository)
			tt.setupMocks(mockRepo)

			// Use real service (it's a stateless domain service)
			service := payment.NewService()
			uc := NewExpirePaymentsUseCase(mockRepo, service)
			ctx := helpers.TestContext(t)

			// Execute
			result, err := uc.Execute(ctx, tt.request)

			// Assert error
			if tt.wantErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}

			// Assert counts
			assert.Equal(t, tt.wantExpiredCount, result.ExpiredCount, "expired count mismatch")
			assert.Equal(t, tt.wantFailedCount, result.FailedCount, "failed count mismatch")
			assert.Len(t, result.Errors, tt.wantErrorsCount, "errors count mismatch")

			// Verify mock expectations
			mockRepo.AssertExpectations(t)
		})
	}
}
