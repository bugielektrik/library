package paymentops

import (
	"library-service/test/helpers"
	"library-service/test/builders"
	"library-service/internal/adapters/repository/mocks"
	"context"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"

	"library-service/internal/domain/payment"
	"library-service/pkg/errors"
)

func TestCancelPaymentUseCase_Execute(t *testing.T) {
	now := time.Now()

	tests := []struct {
		name         string
		request      CancelPaymentRequest
		setupMock    func(*mocks.MockPaymentRepository)
		wantErr      bool
		wantErrType  error
		validateResp func(*testing.T, CancelPaymentResponse)
	}{
		{
			name: "successfully cancel pending payment",
			request: CancelPaymentRequest{
				PaymentID: "payment-1",
				MemberID:  "member-1",
				Reason:    "Changed mind",
			},
			setupMock: func(repo *mocks.MockPaymentRepository) {
				paymentEntity := payment.Payment{
					ID:        "payment-1",
					InvoiceID: "inv-1",
					MemberID:  "member-1",
					Amount:    10000,
					Currency:  "KZT",
					Status:    payment.StatusPending,
					CreatedAt: now,
				}

				repo.On("GetByID", mock.Anything, "payment-1").
					Return(paymentEntity, nil)

				repo.On("UpdateStatus", mock.Anything, "payment-1", payment.StatusCancelled).
					Return(nil)
			},
			wantErr: false,
			validateResp: func(t *testing.T, resp CancelPaymentResponse) {
				assert.Equal(t, "payment-1", resp.PaymentID)
				assert.Equal(t, payment.StatusCancelled, resp.Status)
				assert.NotZero(t, resp.CancelledAt)
			},
		},
		{
			name: "successfully cancel processing payment",
			request: CancelPaymentRequest{
				PaymentID: "payment-2",
				MemberID:  "member-1",
				Reason:    "Timeout",
			},
			setupMock: func(repo *mocks.MockPaymentRepository) {
				paymentEntity := payment.Payment{
					ID:        "payment-2",
					InvoiceID: "inv-2",
					MemberID:  "member-1",
					Amount:    5000,
					Currency:  "KZT",
					Status:    payment.StatusProcessing,
					CreatedAt: now,
				}

				repo.On("GetByID", mock.Anything, "payment-2").
					Return(paymentEntity, nil)

				repo.On("UpdateStatus", mock.Anything, "payment-2", payment.StatusCancelled).
					Return(nil)
			},
			wantErr: false,
			validateResp: func(t *testing.T, resp CancelPaymentResponse) {
				assert.Equal(t, "payment-2", resp.PaymentID)
				assert.Equal(t, payment.StatusCancelled, resp.Status)
			},
		},
		{
			name: "error - payment not found",
			request: CancelPaymentRequest{
				PaymentID: "nonexistent",
				MemberID:  "member-1",
				Reason:    "Test",
			},
			setupMock: func(repo *mocks.MockPaymentRepository) {
				repo.On("GetByID", mock.Anything, "nonexistent").
					Return(payment.Payment{}, errors.ErrNotFound)
			},
			wantErr:     true,
			wantErrType: errors.ErrPaymentNotFound,
		},
		{
			name: "error - unauthorized member attempting cancellation",
			request: CancelPaymentRequest{
				PaymentID: "payment-3",
				MemberID:  "wrong-member",
				Reason:    "Test",
			},
			setupMock: func(repo *mocks.MockPaymentRepository) {
				paymentEntity := payment.Payment{
					ID:        "payment-3",
					InvoiceID: "inv-3",
					MemberID:  "actual-member",
					Amount:    10000,
					Currency:  "KZT",
					Status:    payment.StatusPending,
					CreatedAt: now,
				}

				repo.On("GetByID", mock.Anything, "payment-3").
					Return(paymentEntity, nil)
			},
			wantErr:     true,
			wantErrType: errors.ErrNotFound,
		},
		{
			name: "error - cannot cancel completed payment",
			request: CancelPaymentRequest{
				PaymentID: "payment-completed",
				MemberID:  "member-1",
				Reason:    "Test",
			},
			setupMock: func(repo *mocks.MockPaymentRepository) {
				paymentEntity := payment.Payment{
					ID:        "payment-completed",
					InvoiceID: "inv-completed",
					MemberID:  "member-1",
					Amount:    10000,
					Currency:  "KZT",
					Status:    payment.StatusCompleted,
					CreatedAt: now,
				}

				repo.On("GetByID", mock.Anything, "payment-completed").
					Return(paymentEntity, nil)
			},
			wantErr:     true,
			wantErrType: errors.ErrInvalidPaymentStatus,
		},
		{
			name: "error - payment already cancelled",
			request: CancelPaymentRequest{
				PaymentID: "payment-cancelled",
				MemberID:  "member-1",
				Reason:    "Test",
			},
			setupMock: func(repo *mocks.MockPaymentRepository) {
				paymentEntity := payment.Payment{
					ID:        "payment-cancelled",
					InvoiceID: "inv-cancelled",
					MemberID:  "member-1",
					Amount:    10000,
					Currency:  "KZT",
					Status:    payment.StatusCancelled,
					CreatedAt: now,
				}

				repo.On("GetByID", mock.Anything, "payment-cancelled").
					Return(paymentEntity, nil)
			},
			wantErr:     true,
			wantErrType: errors.ErrPaymentAlreadyProcessed,
		},
		{
			name: "error - cannot cancel refunded payment",
			request: CancelPaymentRequest{
				PaymentID: "payment-refunded",
				MemberID:  "member-1",
				Reason:    "Test",
			},
			setupMock: func(repo *mocks.MockPaymentRepository) {
				paymentEntity := payment.Payment{
					ID:        "payment-refunded",
					InvoiceID: "inv-refunded",
					MemberID:  "member-1",
					Amount:    10000,
					Currency:  "KZT",
					Status:    payment.StatusRefunded,
					CreatedAt: now,
				}

				repo.On("GetByID", mock.Anything, "payment-refunded").
					Return(paymentEntity, nil)
			},
			wantErr:     true,
			wantErrType: errors.ErrInvalidPaymentStatus,
		},
		{
			name: "error - invalid status transition from failed",
			request: CancelPaymentRequest{
				PaymentID: "payment-failed",
				MemberID:  "member-1",
				Reason:    "Test",
			},
			setupMock: func(repo *mocks.MockPaymentRepository) {
				paymentEntity := payment.Payment{
					ID:        "payment-failed",
					InvoiceID: "inv-failed",
					MemberID:  "member-1",
					Amount:    10000,
					Currency:  "KZT",
					Status:    payment.StatusFailed,
					CreatedAt: now,
				}

				repo.On("GetByID", mock.Anything, "payment-failed").
					Return(paymentEntity, nil)
			},
			wantErr:     true,
			wantErrType: errors.ErrValidation,
		},
		{
			name: "error - database error on UpdateStatus",
			request: CancelPaymentRequest{
				PaymentID: "payment-db-error",
				MemberID:  "member-1",
				Reason:    "Test",
			},
			setupMock: func(repo *mocks.MockPaymentRepository) {
				paymentEntity := payment.Payment{
					ID:        "payment-db-error",
					InvoiceID: "inv-db-error",
					MemberID:  "member-1",
					Amount:    10000,
					Currency:  "KZT",
					Status:    payment.StatusPending,
					CreatedAt: now,
				}

				repo.On("GetByID", mock.Anything, "payment-db-error").
					Return(paymentEntity, nil)

				repo.On("UpdateStatus", mock.Anything, "payment-db-error", payment.StatusCancelled).
					Return(errors.ErrDatabase)
			},
			wantErr:     true,
			wantErrType: errors.ErrDatabase,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Setup
			mockRepo := new(mocks.MockPaymentRepository)
			tt.setupMock(mockRepo)

			// Use real domain service
			service := payment.NewService()
			uc := NewCancelPaymentUseCase(mockRepo, service)
			ctx := helpers.TestContext(t)

			// Execute
			result, err := uc.Execute(ctx, tt.request)

			// Assert error
			if tt.wantErr {
				assert.Error(t, err)
				if tt.wantErrType != nil {
					assert.ErrorIs(t, err, tt.wantErrType)
				}
			} else {
				assert.NoError(t, err)

				// Run custom validation if provided
				if tt.validateResp != nil {
					tt.validateResp(t, result)
				}
			}

			// Verify mock expectations
			mockRepo.AssertExpectations(t)
		})
	}
}
