package reservationops

import (
	"library-service/test/helpers"
	"library-service/test/builders"
	"library-service/internal/adapters/repository/mocks"
	"context"
	"testing"
	"time"

	"github.com/stretchr/testify/mock"

	"library-service/internal/domain/member"
	"library-service/internal/domain/reservation"
	"library-service/pkg/errors"
	"library-service/test/fixtures"
)

// mockReservationRepository is a mock implementation of reservation.Repository for testing
type mockReservationRepository struct {
	mock.Mock
}

func (m *mocks.MockReservationRepository) Create(ctx context.Context, data reservation.Reservation) (string, error) {
	args := m.Called(ctx, data)
	return args.String(0), args.Error(1)
}

func (m *mocks.MockReservationRepository) GetByID(ctx context.Context, id string) (reservation.Reservation, error) {
	args := m.Called(ctx, id)
	return args.Get(0).(reservation.Reservation), args.Error(1)
}

func (m *mocks.MockReservationRepository) GetByMemberID(ctx context.Context, memberID string) ([]reservation.Reservation, error) {
	args := m.Called(ctx, memberID)
	return args.Get(0).([]reservation.Reservation), args.Error(1)
}

func (m *mocks.MockReservationRepository) GetActiveByMemberAndBook(ctx context.Context, memberID, bookID string) ([]reservation.Reservation, error) {
	args := m.Called(ctx, memberID, bookID)
	return args.Get(0).([]reservation.Reservation), args.Error(1)
}

func (m *mocks.MockReservationRepository) Update(ctx context.Context, data reservation.Reservation) error {
	args := m.Called(ctx, data)
	return args.Error(0)
}

func (m *mocks.MockReservationRepository) GetByBookID(ctx context.Context, bookID string) ([]reservation.Reservation, error) {
	args := m.Called(ctx, bookID)
	return args.Get(0).([]reservation.Reservation), args.Error(1)
}

func (m *mocks.MockReservationRepository) ListPending(ctx context.Context) ([]reservation.Reservation, error) {
	args := m.Called(ctx)
	return args.Get(0).([]reservation.Reservation), args.Error(1)
}

func (m *mocks.MockReservationRepository) ListExpired(ctx context.Context) ([]reservation.Reservation, error) {
	args := m.Called(ctx)
	return args.Get(0).([]reservation.Reservation), args.Error(1)
}

func (m *mocks.MockReservationRepository) Cancel(ctx context.Context, id string) error {
	args := m.Called(ctx, id)
	return args.Error(0)
}

func (m *mocks.MockReservationRepository) Delete(ctx context.Context, id string) error {
	args := m.Called(ctx, id)
	return args.Error(0)
}

// mockMemberRepository is a mock implementation of member.Repository for testing
type mockMemberRepository struct {
	mock.Mock
}

func (m *mocks.MockMemberRepository) Add(ctx context.Context, data member.Member) (string, error) {
	args := m.Called(ctx, data)
	return args.String(0), args.Error(1)
}

func (m *mocks.MockMemberRepository) Get(ctx context.Context, id string) (member.Member, error) {
	args := m.Called(ctx, id)
	return args.Get(0).(member.Member), args.Error(1)
}

func (m *mocks.MockMemberRepository) GetByEmail(ctx context.Context, email string) (member.Member, error) {
	args := m.Called(ctx, email)
	return args.Get(0).(member.Member), args.Error(1)
}

func (m *mocks.MockMemberRepository) Update(ctx context.Context, id string, data member.Member) error {
	args := m.Called(ctx, id, data)
	return args.Error(0)
}

func (m *mocks.MockMemberRepository) Delete(ctx context.Context, id string) error {
	args := m.Called(ctx, id)
	return args.Error(0)
}

func (m *mocks.MockMemberRepository) List(ctx context.Context) ([]member.Member, error) {
	args := m.Called(ctx)
	return args.Get(0).([]member.Member), args.Error(1)
}

func (m *mocks.MockMemberRepository) EmailExists(ctx context.Context, email string) (bool, error) {
	args := m.Called(ctx, email)
	return args.Bool(0), args.Error(1)
}

func (m *mocks.MockMemberRepository) GetBooksBorrowed(ctx context.Context, memberID string) ([]string, error) {
	args := m.Called(ctx, memberID)
	return args.Get(0).([]string), args.Error(1)
}

func (m *mocks.MockMemberRepository) UpdateLastLogin(ctx context.Context, id string, loginTime time.Time) error {
	args := m.Called(ctx, id, loginTime)
	return args.Error(0)
}

func TestCreateReservationUseCase_Execute(t *testing.T) {
	tests := []struct {
		name         string
		request      CreateReservationRequest
		setupMocks   func(*mocks.MockReservationRepository, *mocks.MockMemberRepository)
		expectError  bool
		errorCheck   func(*testing.T, error)
		validateFunc func(*testing.T, CreateReservationResponse)
	}{
		{
			name: "successful reservation creation",
			request: CreateReservationRequest{
				BookID:   "book-123",
				MemberID: "member-123",
			},
			setupMocks: func(reservationRepo *mocks.MockReservationRepository, memberRepo *mocks.MockMemberRepository) {
				// Member exists with no borrowed books
				memberEntity := fixtures.ValidMember()
				memberEntity.ID = "member-123"
				memberEntity.Books = []string{} // No borrowed books

				memberRepo.On("Get", mock.Anything, "member-123").
					Return(memberEntity, nil).
					Once()

				// No active reservations for this book
				reservationRepo.On("GetActiveByMemberAndBook", mock.Anything, "member-123", "book-123").
					Return([]reservation.Reservation{}, nil).
					Once()

				// Reservation creation succeeds
				reservationRepo.On("Create", mock.Anything, mock.MatchedBy(func(r reservation.Reservation) bool {
					return r.BookID == "book-123" &&
						r.MemberID == "member-123" &&
						r.Status == reservation.StatusPending
				})).
					Return("reservation-123", nil).
					Once()
			},
			expectError: false,
			validateFunc: func(t *testing.T, resp CreateReservationResponse) {
				helpers.AssertEqual(t, "reservation-123", resp.ID)
				helpers.AssertEqual(t, "book-123", resp.BookID)
				helpers.AssertEqual(t, "member-123", resp.MemberID)
			},
		},
		{
			name: "member not found",
			request: CreateReservationRequest{
				BookID:   "book-123",
				MemberID: "non-existent-member",
			},
			setupMocks: func(reservationRepo *mocks.MockReservationRepository, memberRepo *mocks.MockMemberRepository) {
				// Member doesn't exist
				memberRepo.On("Get", mock.Anything, "non-existent-member").
					Return(member.Member{}, errors.ErrNotFound).
					Once()
			},
			expectError: true,
			errorCheck: func(t *testing.T, err error) {
				helpers.AssertError(t, err)
				helpers.AssertErrorContains(t, err.Error(), "not found")
			},
		},
		{
			name: "member already has active reservation for this book",
			request: CreateReservationRequest{
				BookID:   "book-123",
				MemberID: "member-123",
			},
			setupMocks: func(reservationRepo *mocks.MockReservationRepository, memberRepo *mocks.MockMemberRepository) {
				// Member exists
				memberEntity := fixtures.ValidMember()
				memberEntity.ID = "member-123"
				memberEntity.Books = []string{}

				memberRepo.On("Get", mock.Anything, "member-123").
					Return(memberEntity, nil).
					Once()

				// Active reservation exists
				activeReservation := fixtures.PendingReservation()
				activeReservation.BookID = "book-123"
				activeReservation.MemberID = "member-123"

				reservationRepo.On("GetActiveByMemberAndBook", mock.Anything, "member-123", "book-123").
					Return([]reservation.Reservation{activeReservation}, nil).
					Once()
			},
			expectError: true,
			errorCheck: func(t *testing.T, err error) {
				helpers.AssertError(t, err)
				// Error comes from domain validation
			},
		},
		{
			name: "member already borrowed the book",
			request: CreateReservationRequest{
				BookID:   "book-123",
				MemberID: "member-123",
			},
			setupMocks: func(reservationRepo *mocks.MockReservationRepository, memberRepo *mocks.MockMemberRepository) {
				// Member exists and already has the book borrowed
				memberEntity := fixtures.ValidMember()
				memberEntity.ID = "member-123"
				memberEntity.Books = []string{"book-123"} // Already borrowed

				memberRepo.On("Get", mock.Anything, "member-123").
					Return(memberEntity, nil).
					Once()

				// No active reservations (already borrowed)
				reservationRepo.On("GetActiveByMemberAndBook", mock.Anything, "member-123", "book-123").
					Return([]reservation.Reservation{}, nil).
					Once()
			},
			expectError: true,
			errorCheck: func(t *testing.T, err error) {
				helpers.AssertError(t, err)
				// Error comes from domain validation
			},
		},
		{
			name: "repository error during creation",
			request: CreateReservationRequest{
				BookID:   "book-123",
				MemberID: "member-123",
			},
			setupMocks: func(reservationRepo *mocks.MockReservationRepository, memberRepo *mocks.MockMemberRepository) {
				// Member exists
				memberEntity := fixtures.ValidMember()
				memberEntity.ID = "member-123"
				memberEntity.Books = []string{}

				memberRepo.On("Get", mock.Anything, "member-123").
					Return(memberEntity, nil).
					Once()

				// No active reservations
				reservationRepo.On("GetActiveByMemberAndBook", mock.Anything, "member-123", "book-123").
					Return([]reservation.Reservation{}, nil).
					Once()

				// Repository error during creation
				reservationRepo.On("Create", mock.Anything, mock.Anything).
					Return("", errors.ErrDatabase).
					Once()
			},
			expectError: true,
			errorCheck: func(t *testing.T, err error) {
				helpers.AssertError(t, err)
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Setup mocks
			mockReservationRepo := new(mocks.MockReservationRepository)
			mockMemberRepo := new(mocks.MockMemberRepository)
			tt.setupMocks(mockReservationRepo, mockMemberRepo)

			// Create real service
			reservationService := reservation.NewService()

			// Create use case
			uc := NewCreateReservationUseCase(mockReservationRepo, mockMemberRepo, reservationService)

			// Execute
			ctx := helpers.TestContext(t)
			result, err := uc.Execute(ctx, tt.request)

			// Assert
			if tt.expectError {
				helpers.AssertError(t, err)
				if tt.errorCheck != nil {
					tt.errorCheck(t, err)
				}
			} else {
				helpers.AssertNoError(t, err)
				if tt.validateFunc != nil {
					tt.validateFunc(t, result)
				}
			}

			// Verify all expectations were met
			mockReservationRepo.AssertExpectations(t)
			mockMemberRepo.AssertExpectations(t)
		})
	}
}
